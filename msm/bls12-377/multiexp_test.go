// Code generated by consensys/gnark-crypto DO NOT EDIT

package bls12377

import (
	"bytes"
	"math/big"
	"os"
	"testing"

	"github.com/gbotrel/zprize-mobile-harness/msm/bls12-377/fr"
	"github.com/stretchr/testify/require"
)

func TestMultiExp(t *testing.T) {
	assert := require.New(t)
	scalars, err := ReadScalars("scalars")
	assert.NoError(err, "reading scalar file")
	points, err := ReadPoints("points")
	assert.NoError(err, "reading points file")
	results, err := ReadResults("result")
	assert.NoError(err, "reading results file")

	assert.True(len(scalars) == len(points))
	assert.True(len(scalars) == len(results))

	// perform the msms 
	for i := 0; i < len(scalars); i++ {
		for J := 0; J < len(scalars[i]); J++ {
			scalars[i][J].FromMont()
		}
		var p G1Affine
		_, err = p.MultiExp(points[i], scalars[i])
		assert.NoError(err)

		assert.True(p.Equal(&results[i]), "msm mismatch")
	}
}

func TestSerializationScalars(t *testing.T) {
	assert := require.New(t)

	scalars, err := ReadScalars("scalars")
	assert.NoError(err, "reading scalar file")
	
	bScalars := SerializeScalars(scalars)
	fScalars, err := os.ReadFile("scalars")
	assert.NoError(err, "reading scalar file 2nd time")

	assert.True(bytes.Equal(bScalars, fScalars), "bad encoding of scalars")
}


func TestSerializationPoints(t *testing.T) {
	assert := require.New(t)

	points, err := ReadPoints("points")
	assert.NoError(err, "reading points file")
	
	bPoints := SerializePoints(points)
	fPoints, err := os.ReadFile("points")
	assert.NoError(err, "reading points file 2nd time")

	assert.True(bytes.Equal(bPoints, fPoints), "bad encoding of points")
}


func TestSerializationResults(t *testing.T) {
	assert := require.New(t)

	points, err := ReadResults("result")
	assert.NoError(err, "reading results file")
	
	bPoints := SerializeResults(points)
	fPoints, err := os.ReadFile("result")
	assert.NoError(err, "reading results file 2nd time")

	assert.True(bytes.Equal(bPoints, fPoints), "bad encoding of results")
}


func BenchmarkMultiExpG1Reference(b *testing.B) {
	const nbSamples = 1 << 14

	var (
		samplePoints  [nbSamples]G1Affine
		sampleScalars [nbSamples]fr.Element
	)

	fillBenchScalars(sampleScalars[:])
	fillBenchBasesG1(samplePoints[:])

	var testPoint G1Jac

	b.ResetTimer()
	for j := 0; j < b.N; j++ {
		testPoint.MultiExp(samplePoints[:], sampleScalars[:], 10)
	}
}


// WARNING: this return points that are NOT on the curve and is meant to be use for benchmarking
// purposes only. We don't check that the result is valid but just measure "computational complexity".
//
// Rationale for generating points that are not on the curve is that for large benchmarks, generating
// a vector of different points can take minutes. Using the same point or subset will bias the benchmark result
// since bucket additions in extended jacobian coordinates will hit doubling algorithm instead of add.
func fillBenchBasesG1(samplePoints []G1Affine) {
	var r big.Int
	r.SetString("340444420969191673093399857471996460938405", 10)
	samplePoints[0].X.SetBigInt(&r)
	samplePoints[0].Y.Neg(&samplePoints[0].X)

	one := samplePoints[0].X
	one.SetOne()

	for i := 1; i < len(samplePoints); i++ {
		samplePoints[i].X.Add(&samplePoints[i-1].X, &one)
		samplePoints[i].Y.Sub(&samplePoints[i-1].Y, &one)
	}
}


func fillBenchScalars(sampleScalars []fr.Element) {
	// ensure every words of the scalars are filled
	var mixer fr.Element
	mixer.SetString("7716837800905789770901243404444209691916730933998574719964609384059111546487")
	for i := 1; i <= len(sampleScalars); i++ {
		sampleScalars[i-1].SetUint64(uint64(i)).
			Mul(&sampleScalars[i-1], &mixer).
			FromMont()
	}
}
